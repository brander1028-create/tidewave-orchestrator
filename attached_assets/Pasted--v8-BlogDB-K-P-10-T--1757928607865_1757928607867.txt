[유연 사양 v8 — 결과 보고서 + BlogDB + 전수 기록(변수 기반), 재구축 금지]

■ 핵심
- K=입력 키워드 수, P=최근글 수(기본 10), T=티어 수(기본 4).
- “전수 검사 수(Checks)” = Σ(각 키워드 k의 NEW_k × P × T). (숫자 강제 X, 런타임 계산)
- Phase1 NEW는 **항상 리스트**로 보이고, Phase2 통과/미통과와 **무관하게** 상세에 전수 결과(0/미확인 포함)를 보여줌.
- 모든 전수 결과는 DB에 기록(조회/집계만, 스키마 최소).

────────────────────────────────────────────────

■ 페이지 구조(최종)
1) 헤더
   - 키워드 칩: [K1] [K2] … (클릭 시 해당 카드로 스크롤)
   - 상태/분석일시, CSV 버튼

2) 키워드별 요약 카드 (입력 키워드마다 1장)
   - 제목: “{키워드}   검색량 {fmtVol(searchVolume)}”
     * searchVolume: DB 미스 시 즉시 API 폴백→upsert→**이번 응답에 반영**
   - KPI 줄:
     • NEW {new}/{total} · Phase2(신규) {exposedNew}/{new} · **검사 {checks}**
     (checks = NEW×P×T, 실시간 계산)
   - 버튼: [자세히] [블로그DB 이동]

3) “자세히” (항상 2섹션)
   3-1) 블로그 리스트(신규만)
       [블로그명(새창) | 총 노출수 | 총합 점수 | 상태 버튼(수집/블랙/섭외)]
       - 총 노출수 = rank≤10 개수 합, 총합 점수 = 위 항목들의 totalScore 합
       - 행 클릭 → 블로그 상세(접기/펼침)

   3-2) 블로그 상세(행 펼침)
       A. 통합 Top 키워드(블로그 전체, 상위 10 · 더보기)
          칩: “{키워드}{[관련X]} · {fmtVol(volume)} · {score}pts · {fmtRank(rank)}”
       B. **포스트별 1~T티어 (P개 포스트 전수)**
          각 포스트 카드: [제목] 아래에
          “1티어 {키} · {볼륨} · {순위} / 2티어 … / … / T티어 …”
          * 순위 포맷: null→“미확인”, 0→“0”, 1~10→“모바일 1p #N”, 11+→“미노출”
          * 볼륨 포맷: null→“–”, 0→“0”

4) BlogDB (/blog-database)
   - 탭: [수집됨] [블랙리스트] [섭외됨] [전체]
   - 표: [블로그명(새창) | 상태 | 최초수집일 | 최근본날짜 | 메모/태그 | 상태변경]
   - 결과 화면의 [블로그DB 이동]은 해당 키워드 필터 상태로 진입
   - Phase1 큐잉 이전에 blog_registry 조회 → status in ('blacklist','outreach')는 **수집 제외**
   - NEW 계산은 blog_registry 기준

────────────────────────────────────────────────

■ 서버 — 응답 계약(동적, 스키마 추가 없이 “조립만” 보강)
GET /api/serp/jobs/:id/results  예시(값은 가변)
{
  "keywords": ["K1","K2"],
  "status": "완료",
  "analyzedAt": "…",
  "params": { "postsPerBlog": P, "tiersPerPost": T },      // ← 변수 공개
  "searchVolumes": { "K1": 39840, "K2": 124000 },           // DB→미스면 API 폴백 후 이번 응답에 반영
  "attemptsByKeyword": { "K1": NEW_K1 * P * T, "K2": NEW_K2 * P * T },
  "exposureStatsByKeyword": { "K1": { "page1": n, "zero": m, "unknown": u }, "K2": { … } },
  "summaryByKeyword": [
    {
      "keyword": "K1",
      "searchVolume": 39840|null,
      "totalBlogs": 12,
      "newBlogs": 5,
      "phase2ExposedNew": 2,
      "blogs": [
        {
          "blogId": "aaa",
          "blogName": "블로그A",
          "blogUrl": "https://blog.naver.com/aaa",
          "status": "collected",
          "totalExposed": 7,
          "totalScore": 486,
          "topKeywords": [
            {"text":"키1","volume":39840,"score":86,"rank":3,"related":true},
            {"text":"키2","volume":12400,"score":72,"rank":0,"related":false}
          ],
          "posts": [
            {
              "title": "포스트 제목 #1",
              "tiers": [
                {"tier":1,"text":"…","volume":855600,"rank":0},
                {"tier":2,"text":"…","volume":6910,"rank":null},
                {"tier":3,"text":"…","volume":11040,"rank":12},  // 저장은 12, 화면표기는 “미노출”
                {"tier":4,"text":"…","volume":2050,"rank":3}
              ]
            }
            // ← 이런 카드가 P개(기본 10개)
          ]
        }
      ]
    }
  ]
}

주의
- “DB 전용/미적용”과 같은 내부 배지는 응답에 싣지 말 것(로그 전용).
- rank=0/ null/ >10을 **그대로** 유지(프론트 포맷 함수 처리).

────────────────────────────────────────────────

■ 전수 기록(최소 마이그 1개, 숫자 비고정)
테이블: post_tier_checks   // (v6의 고정 40 아님, P/T 가변!)
- id TEXT PK                      // ex) sha1(job_id|input_kw|blog_id|post_id|tier|text_nrm)
- job_id TEXT NOT NULL
- input_keyword TEXT NOT NULL     // 사용자가 입력한 키워드 구분
- blog_id TEXT NOT NULL
- post_id TEXT NOT NULL
- post_title TEXT NOT NULL
- tier SMALLINT NOT NULL          // 1..T
- text_surface TEXT NOT NULL
- text_nrm TEXT NOT NULL
- volume INTEGER NULL
- rank INTEGER NULL               // 0 | 1.. | null
- device TEXT NULL                // 'mobile'|'pc'
- related BOOLEAN NOT NULL DEFAULT false
- created_at TIMESTAMP NOT NULL DEFAULT now()
UNIQUE(job_id,input_keyword,blog_id,post_id,tier,text_nrm)
INDEX(job_id,input_keyword), INDEX(blog_id), INDEX(post_id), INDEX(rank)

파이프라인
- Phase1 NEW 산정(키워드별) → 각 블로그의 최근글 P개 로드 → 각 포스트에서 티어 1..T 추출
- 각 티어에 대해: volume(DB→API 폴백)·rank(모바일 기본) 계산 → **즉시 upsert(post_tier_checks)**
- 집계는 화면 조립 시 쿼리로 계산(숫자 고정 없음)

────────────────────────────────────────────────

■ 프론트 포맷 함수 (통일)
fmtVol(v)  = v==null ? "–" : v.toLocaleString()
fmtRank(r) = r==null ? "미확인" : (r===0 ? "0" : (r<=10 ? `모바일 1p #${r}` : "미노출"))

정렬 규칙(기본)
- 키워드 카드: (exposedNew/new) 내림차순 → new 내림차순
- 블로그 리스트: totalExposed 내림차순 → totalScore 내림차순
- 통합 Top 키워드: (0.7·volumeScale + 0.3·contentScore) 내림차순

────────────────────────────────────────────────

■ BlogDB 연동(필수)
- 테이블: blog_registry(blog_id PK, url, name, status('collected'|'blacklist'|'outreach'), tags, note, first_seen_at, last_seen_at, created_at, updated_at)
- Phase1 큐잉 이전에 blog_registry 조회→status in ('blacklist','outreach') 제외
- 결과/BlogDB에서 상태 변경 POST /api/blogs/:id/status {status}

────────────────────────────────────────────────

■ DoD (숫자 고정 없이, 변수 기반 확인)
- [ ] 헤더에 키워드 칩과 상태/날짜가 보인다.
- [ ] 각 키워드 카드에 “검색량”, “NEW/총”, “Phase2(신규)”, “검사 {checks}(=NEW×P×T)”가 동적으로 보인다.
- [ ] “자세히”에서 **NEW 블로그 전부**가 표로 보이고, 각 블로그를 펼치면 **포스트 P개 × 티어 T**가 전수로 보인다(0/미확인 포함).
- [ ] 전수 결과는 post_tier_checks에 행 단위로 저장되어, 재방문 시 그대로 복기된다.
- [ ] searchVolume은 DB 미스 시 같은 응답에서 숫자로 채워진다(API 폴백 반영).
- [ ] “DB 전용/미적용” 배지는 화면에 없다(로그 전용).
