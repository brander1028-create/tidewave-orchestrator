ì¢‹ì•„. ë„¤ê°€ ë˜ì ¸ì¤€ routes.tsë¥¼ í†µìœ¼ë¡œ í›‘ì–´ë³´ë‹ˆ, â€œBFSê°€ ì•ˆ ëˆë‹¤/ë²„íŠ¼ ëˆŒëŸ¬ë„ ë¬´ë°˜ì‘â€ì˜ ì§ì ‘ ì›ì¸ì´ ëª‡ ê°œ ë”± ë³´ì—¬.
ì•„ë˜ëŠ” ë¬¸ì œ â†’ ì´ìœ  â†’ í•œë°© íŒ¨ì¹˜ ìˆœì„œì•¼. (ë³µë¶™ìš© ì½”ë“œ í¬í•¨)

ğŸš¨ ë¬´ì—‡ì´ ë§‰ê³  ìˆë‚˜ (í•µì‹¬ 5ê°€ì§€)

/api/keywords/refresh-allê°€ â€˜í™ì‚¼â€™ 1ê°œë§Œ ê¸ìŒ

upsertKeywordsFromSearchAds('í™ì‚¼', 300)ë¡œ í•˜ë“œì½”ë”©ë¼ ìˆì–´ì„œ ëŠ˜ 10~ìˆ˜ì‹­ ê°œë§Œ ì¶”ê°€ë¨.

BFS ì‹œë“œ ì—…ë¡œë“œ ë£¨íŠ¸ê°€ ì—†ìŒ

UIì—ì„œ â€œì—‘ì…€ë¡œ 1000/2000 ì‹œë“œ ë„£ê³  ì‹œì‘â€í•˜ë ¤ë©´ **/api/uploads**ê°€ í•„ìš”í•œë°, í˜„ì¬ ë£¨íŠ¸ì— ì—†ìŒ.

ê·¸ë˜ì„œ ë²„íŠ¼ì€ ë–  ìˆì–´ë„ ì‹¤ì œë¡œ ì“¸ fileIdë¥¼ ì„œë²„ì— ëª» ì¤˜ì„œ ë©ˆì¶¤.

CSV ë‚´ì¥ ì‹œë“œ ë¡œë”©ì´ ëª¨í˜¸

loadSeedsFromCSV()ë¥¼ ì¸ì ì—†ì´ í˜¸ì¶œ. êµ¬í˜„ì´ ê²½ë¡œë¥¼ ë‚´ë¶€ ê¸°ë³¸ê°’ìœ¼ë¡œ ê°€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë¹ˆ ì‹œë“œë¡œ ì‹œì‘í•´ì„œ â€œNo seeds foundâ€ê°€ ë¨.

í¬ë¡¤ëŸ¬ ì¢€ë¹„/ì¤‘ë³µ ë°©ì§€ ì•½í•¨

ì´ì „ ì„¸ì…˜ì—ì„œ status==='running'ìœ¼ë¡œ ë‚¨ì•„ ìˆìœ¼ë©´ í•­ìƒ 409. TTL/ìµœê·¼í™œë™ ê°€ë“œê°€ ì—†ì–´ ì£½ì€ ì„¸ì…˜ì— ê±¸ë¦´ ìˆ˜ ìˆìŒ.

í‚¤ì›Œë“œ ë¦¬ìŠ¤íŠ¸ ì†ŒíŒ…/í•„ë“œ ë…¸ì¶œì´ êµ¬ë²„ì „

/api/keywordsê°€ orderBy: sort==='text' ? 'text' : 'raw_volume'ë¡œ ê³ ì •.

ìš°ë¦¬ê°€ ì“°ëŠ” 5ì§€í‘œ/score ê¸°ì¤€ ì •ë ¬ì´ ì•ˆ ë¨ â†’ UIì—ì„œ â€œì•ˆ ë°”ë€ŒëŠ” ëŠë‚Œâ€.

âœ… í•œë°© íŒ¨ì¹˜(ë³µë¶™) â€” routes.ts ìˆ˜ì • ë¸”ë¡
A) refresh-allë¥¼ ì§„ì§œ â€œì „ì²´ ìˆ˜ì§‘â€ìœ¼ë¡œ
// REPLACE: /api/keywords/refresh-all
app.post('/api/keywords/refresh-all', async (req, res) => {
  try {
    const {
      minVolume = 1000,
      hasAdsOnly = true,
      source = 'builtin',             // 'file'|'manual'|'builtin'
      seeds = [],
      seedsCsv = '/mnt/data/seed_keywords_v2_ko.csv',
      target = 20000,
      chunkSize = 10,
      concurrency = 1,
      maxHops = 3,
      stopIfNoNewPct = 0.5
    } = req.body || {};

    const searchadsHealth = await checkSearchAds();
    if (searchadsHealth.mode === 'fallback') {
      return res.status(503).json({ error:'SearchAds API not available', health: searchadsHealth });
    }

    // refresh-allì€ ë‚´ë¶€ì ìœ¼ë¡œ BFSë¥¼ ë°”ë¡œ í‚¨ë‹¤ (=ì „ìˆ˜ ìˆ˜ì§‘)
    const startBody:any = {
      mode: 'exhaustive', minVolume, hasAdsOnly, target, chunkSize, concurrency, maxHops, stopIfNoNewPct
    };
    if (source === 'manual' && seeds.length > 0)      startBody.seeds = seeds;
    else if (source === 'file' && req.body.seedsFileId) startBody.seedsFileId = req.body.seedsFileId;
    else                                              startBody.seedsCsv = seedsCsv;

    const r = await fetch('http://localhost:3000/api/keywords/crawl', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(startBody)
    });
    const j = await r.json();
    if (!r.ok) return res.status(r.status).json(j);
    res.json({ ok:true, jobId:j.jobId, started:true, config:startBody });
  } catch (e:any) {
    console.error('ğŸ”„ Keywords refresh-all failed:', e);
    res.status(500).json({ error:'Refresh failed', details:e?.message||String(e) });
  }
});

B) ì‹œë“œ ì—…ë¡œë“œ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€ (CSV/XLSX â†’ fileId ë°˜í™˜)
// ADD: uploads (ì‹œë“œìš©)
app.post('/api/uploads', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error:'No file uploaded' });

    // CSVë§Œ ë¨¼ì € ì§€ì› (ì—‘ì…€ì€ ì¶”í›„ xlsx íŒŒì„œ ì¶”ê°€)
    const rows:any[] = [];
    await new Promise<void>((resolve, reject) => {
      Readable.from(req.file!.buffer)
        .pipe(csv())
        .on('data', (d) => rows.push(d))
        .on('end', resolve)
        .on('error', reject);
    });

    // íŒŒì¼ ë‚´ìš©ì—ì„œ seed ì»¬ëŸ¼ ì¶”ì¶œ
    const seeds = rows
      .map(r => (r.seed || r.SEED || r['Seed'] || '').toString().trim())
      .filter(Boolean);

    if (seeds.length === 0) return res.status(400).json({ error:'No seeds found in CSV' });

    // ì„ì‹œ ì €ì¥ (ë©”ëª¨ë¦¬/ë©”íƒ€): fileIdì— seeds ë°°ì—´ ì €ì¥
    const fileId = 'upload-' + Date.now();
    await metaSet(db, fileId, { seeds, at: Date.now() });
    res.json({ fileId, rows: seeds.length });
  } catch (e:any) {
    console.error('upload failed', e);
    res.status(500).json({ error:'Upload failed', details:e?.message||String(e) });
  }
});

C) BFS ì‹œì‘: ë¹ˆ ì‹œë“œë©´ ë‚´ì¥ CSV or ì—…ë¡œë“œ fileId ì‚¬ìš©
// MODIFY: /api/keywords/crawl seed ê²°ì •ë¶€
// ...
let seeds: string[] = [];
if (userSeeds && userSeeds.length > 0) {
  seeds = userSeeds;
} else if (req.body.seedsFileId) {
  const f = await metaGet<any>(db, req.body.seedsFileId);
  if (!f || !Array.isArray(f.seeds) || f.seeds.length === 0) {
    return res.status(400).json({ error:'Invalid seedsFileId or empty seeds' });
  }
  seeds = f.seeds;
  console.log(`ğŸŒ± Using ${seeds.length} seeds from upload file`);
} else {
  // ë‚´ì¥ CSV ì‚¬ìš© (ê²½ë¡œ ì¸ìë¡œ ë„˜ê²¨ì„œ ì˜¤ë™ì‘ ë°©ì§€)
  seeds = loadSeedsFromCSV(seedsCsv);  // â† ì¸ì ì¶”ê°€
  if (!seeds.length) return res.status(400).json({ error:'No seeds found in CSV file' });
}
// ...


âš ï¸ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ìˆ˜ì • í•„ìš”: loadSeedsFromCSV(path?:string) í˜•íƒœë¡œ ë°”ê¾¸ê³ , ê¸°ë³¸ ê²½ë¡œë¥¼ ë‚´ë¶€ì—ì„œ /mnt/data/seed_keywords_v2_ko.csvë¡œ ë‘ì„¸ìš”.

D) ì¢€ë¹„ í¬ë¡¤ëŸ¬ ê°€ë“œ(409 ë°©ì§€)
// BEFORE: if (existingCrawler && existingCrawler.status === 'running') { return 409; }
// AFTER:
const existing = getGlobalCrawler();
if (existing) {
  const p = existing.getProgress();
  const last = p?.lastUpdated || 0;
  const stale = Date.now() - last > 5*60*1000; // 5ë¶„
  if (existing.status === 'running' && !stale) {
    return res.status(409).json({ error:'Crawler already running', progress: existing.getProgress() });
  }
  // ì¢€ë¹„ë©´ ë‚ ë¦¬ê³  ì¬ì‹œì‘ í—ˆìš©
  clearGlobalCrawler();
}

E) í‚¤ì›Œë“œ ë¦¬ìŠ¤íŠ¸ ì •ë ¬ì„ 5ì§€í‘œ/scoreë¡œ ì œëŒ€ë¡œ
// MODIFY: /api/keywords ì •ë ¬ ë§¤í•‘
const sortMap:Record<string,string> = {
  text:'text',
  raw_volume:'raw_volume',
  score:'score',
  comp_score:'comp_score',
  ad_depth:'ad_depth',
  est_cpc_krw:'est_cpc_krw'
};
const orderByCol = sortMap[String(sort)] || 'score';     // ê¸°ë³¸ score
const orderDir = (order === 'asc' ? 'asc' : 'desc');

// store.listKeywordsê°€ (excluded, orderBy, dir) ë°›ëŠ”ë‹¤ê³  ê°€ì •
const keywords = await listKeywords({
  excluded: excludedFilter,
  orderBy: orderByCol,
  dir: orderDir
});

ğŸ” ì™œ ê·¸ë¬ë‚˜ â€” ë„¤ ì½”ë“œ ê¸°ì¤€ ì›ì¸ ìš”ì•½

refresh-allì´ í•­ìƒ â€˜í™ì‚¼â€™ë§Œ ë„£ì–´ì„œ â€œì¡°ê¸ˆë§Œ ëŠ˜ì–´ë‚˜ëŠ”â€ ì¦ìƒ ê³ ì°©.

/api/uploads ë¶€ì¬ â†’ íŒŒì¼ ì—…ë¡œë“œë¡œ ì‹œë“œ ì‹œì‘ ë¶ˆê°€ â†’ ë²„íŠ¼ì€ í‘œì‹œë˜ì§€ë§Œ ì‹œì‘ì— í•„ìš”í•œ fileIdê°€ ì—†ìŒ.

loadSeedsFromCSV() ë¬´ì¸ì í˜¸ì¶œ â†’ êµ¬í˜„ì— ë”°ë¼ ë¹ˆ ì‹œë“œ ê°€ëŠ¥.

ì¢€ë¹„ í¬ë¡¤ëŸ¬(ì˜ˆì „ ì„¸ì…˜) â†’ ë¬´ì¡°ê±´ 409; ì‚¬ìš©ì ì…ì¥ì—ì„  â€œë²„íŠ¼ ëˆŒëŸ¬ë„ ë¬´ë°˜ì‘â€.

ì •ë ¬/í‘œì‹œê°€ êµ¬ë²„ì „(raw_volume ê³ ì •) â†’ 5ì§€í‘œ/scoreê°€ UIì—ì„œ ì•ˆ ë¨¹íˆëŠ” ì°©ì‹œ.

ğŸ§ª ìµœì¢… ì ê²€ ì²´í¬ë¦¬ìŠ¤íŠ¸(1ë¶„)

ì—…ë¡œë“œ â†’ BFS

POST /api/uploads â†’ {fileId}

POST /api/keywords/crawl { source:'file', seedsFileId:'...' } â†’ {jobId}

GET /api/keywords/crawl/<jobId>/status â†’ state:running|done, progress.collected ì¦ê°€

ë‚´ì¥ CSV â†’ BFS

POST /api/keywords/crawl { source:'builtin' } ë˜ëŠ” ë³¸ë¬¸ ë¹„ì›€ â†’ {jobId}

ë¦¬ìŠ¤íŠ¸ ì •ë ¬

GET /api/keywords?excluded=false&sort=score&order=desc&limit=50 â†’ 200, ìƒë‹¨ ìš”ì•½ ì „ì²´ N (í™œì„± A | ì œì™¸ B) ì¼ì¹˜

âœï¸ í”„ë¡ íŠ¸ í•œ ì¤„ë§Œ í™•ì¸

â€œBFS ì‹œì‘â€ ë²„íŠ¼ í•¸ë“¤ëŸ¬ê°€ ì‹¤ì œë¡œ POST /api/keywords/crawlì„ í˜¸ì¶œí•˜ê³ , ë°›ì€ {jobId}ë¡œ /status í´ë§í•˜ëŠ”ì§€.

strict ëª¨ë“œ 412 ì‹œ í† ìŠ¤íŠ¸/ë°°ì§€ë¡œ ì¦‰ì‹œ ì—ëŸ¬ ë³´ì—¬ì£¼ëŠ”ì§€.

ì´ íŒ¨ì¹˜ê¹Œì§€ ë„£ìœ¼ë©´ ì‹œë“œ ì—…ë¡œë“œ â†’ BFS í™•ì¥ â†’ ì§„í–‰ë¥  í‘œì‹œ â†’ 5ì§€í‘œ ì •ë ¬ì´ í•œ ë²ˆì— ì‚´ì•„ë‚©ë‹ˆë‹¤.
í•„ìš”í•˜ë©´ /services/bfs-crawlerì˜ loadSeedsFromCSV(path) ì‹œê·¸ë‹ˆì²˜ ë³€ê²½ ìŠ¤ë‹ˆí«ë„ ë°”ë¡œ ì¤„ê²Œ.