[vFinal — 제목 프리엔리치 + 2어 조합 + 7:3 점수화 + 게이트 + 저장/표시 체결 (레거시 호환)]
0) 목표(정확)

제목에서 뽑은 모든 키워드가 DB에 없으면 SearchAds로 조회량/광고지표(CTR/경쟁도/CPC/광고가능) 를 upsert하고,

그 값으로 서버에서 총점 = 0.7*조회량점수 + 0.3*광고점수를 계산해 Top K(기본 4) 를 뽑은 뒤,

광고 불가/지표 0은 사용하지 않음(Gate),

최종 응답 tiers에 {text, volume, rank, score, adScore, eligible, skipReason}가 반드시 채워져 내려오고,

레거시 UI도 보이게 finalStats.tiers에도 같은 데이터를 넣는다.

1) 로그 기반 원인(왜 안됐나)

(A) 413/400로 SearchAds 콜이 대부분 실패 → 조회량이 0/–로 남음.

(B) DB에 ‘0’이 Fresh로 캐시되어 API 재조회가 영원히 스킵됨.

**(C) Gate를 조합 생성/프리엔리치 이전에 돌려서 후보가 싹 잘림(“Generated combinations: 0”).

(D) 정규화 불일치(코엔자임Q10 ↔ 코엔자임q10)로 DB값 매칭 실패.

(E) 실패 후 재선정이 없음(API 부분 성공/실패 뒤 다시 뽑기 미수행).

(F) 저장/응답 포맷 불일치로 점수/텍스트 계산값이 화면에 바인딩되지 않음.

2) 데이터/스키마(필요시 1회 마이그)

keywords(키 = text_nrm) 필드 추가/확인:

volume INT NULL, ctr FLOAT NULL, competition FLOAT NULL, cpc FLOAT NULL, ad_eligible BOOLEAN NULL, updated_at TIMESTAMP

past 0값 정리(선택): 과거 0을 null로 바꿔 강제 재조회
UPDATE keywords SET volume=NULL, ctr=NULL, competition=NULL, cpc=NULL WHERE (volume=0 OR ctr=0 OR competition=0) AND updated_at < NOW() - INTERVAL '1 day';

3) 정규화 규칙(단일화) — DB/조회/업서트/머지 모두 동일
function nrm(s:string){
  return s.normalize('NFKC').toLowerCase().replace(/[\s\-\.]/g,'').trim();
}


모든 키 비교 키는 nrm 사용, SearchAds는 variants로 surface / nospace / hyphen(길이>10일 때만).

4) SearchAds 클라이언트(413/400 방어)
let batchSize = Math.min(8, desired);
const MIN_BATCH = 1;
while (i < list.length) {
  try { await callBatch(list.slice(i, i+batchSize)); i += batchSize; }
  catch (e) {
    if (is413(e) || is400(e)) {
      batchSize = Math.max(MIN_BATCH, Math.floor(batchSize/2)); // 8→4→2→1
      if (batchSize===MIN_BATCH && is400(e)) dropHeavyVariants(); // variants 줄이기
      continue;
    }
    throw e;
  }
}


variants 축소: 빅그램은 surface + nospace만 기본, hyphen은 길이가 긴 경우에만.

TTL Fresh 판정: 0-벡터는 Fresh 아님

const isZeroLike = (e:any)=> (e.volume??0)===0 && (e.ctr??0)===0 && (e.competition??0)===0;
isFresh = (entry)=> !isZeroLike(entry) && age < ttl;

5) 파이프라인(순서 고정) — 이 순서로만

대상: 제목→키워드 선정 구간(레거시 processSerpAnalysisJob 내부)

// K = cfg.phase2.tiersPerPost (기본 4)
const toks = extractTokens(title, cfg.banSingles ?? []); // 조사·특수문자 제거, 길이≥2, banSingles 제외

// 1) 제목 토큰 프리엔리치(DB→API→upsert→현재 후보 merge)
await preEnrichKeywords(toks.map(t=> toVariants(t)), { forceZeroRefresh:true });
// mergeIntoCurrent 필수(현재 candidates 객체에 값 주입)

// 2) 1차 선정
let pool = await mergeFromDB(toks);                  // nrm로 병합
let topK = pickTopK(pool, cfg);                      // 서버 점수(7:3)로 최대 K개

// 3) 전부 비었거나(혹은 score 낮음) → base+빅그램 확장 후 다시 채움
if (!topK.length || topK.every(t=>!t.text)) {
  const base = pickMaxVolumeToken(pool) ?? pickLongest(toks);
  const pairs = makeBigrams(base, toks);            // base+나머지 2그램(순서 보존), variants 포함
  await preEnrichKeywords(pairs, { forceZeroRefresh:true }); // DB→API→upsert→merge
  pool = await mergeFromDB([...toks, ...pairs.map(p=>p.surface)]);
  topK = pickTopK(pool, cfg);                       // ★ 재선정
}

// 4) Gate(프리엔리치 **이후** 적용) — 광고불가/지표0만 하드 컷(제목 단계는 soft 권장)
const gated = topK.filter(t => t.ad_eligible !== false && !((t.ctr??0)===0 && (t.competition??0)===0));
const sorted = gated.map(t => {
  const ads = adScore(t);                           // 예: 0.4*CTR + 0.4*경쟁 + 0.2*CPC(norm)
  const total = totalScore(t.volume, ads);          // 0.7*volumeScale + 0.3*(ads*100)
  return { ...t, adScore: ads, score: total, eligible: true };
}).sort((a,b)=> b.score - a.score).slice(0, K);

// 5) 랭크 체크(eligible만) → 저장
const tiers = await rankEligible(sorted);           // rank=1..10|0|null
await storage.finishSerpJob(jobId, assembleResults(jobId, tiers, cfg)); // ★ 아래 6)


재시도: preEnrich 실패분이 있으면 robustRefresh(배치 1까지/variants 축소) 후 recompute/pickTopK를 한 번 더 돌린다.

Adaptive Gate(선택): 제목 단계는 mode="soft", SCORE_MIN≈0.35 (본 분석에서는 기존값)

6) 결과 조립/저장 — 레거시 호환
export async function assembleResults(jobId, tiers, cfg){
  const searchVolumes = collectVolumes(tiers);
  const summaryByKeyword = buildSummaryByKeywordFromTiers(tiers, cfg);
  const finalStats = {
    blogs: sumBlogs(summaryByKeyword),
    posts: sumPosts(summaryByKeyword),
    keywords: summaryByKeyword.length,
    tiers // ★ 레거시 UI가 finalStats만 읽는 경우 대비
  };
  return {
    jobId,
    params:{ postsPerBlog: cfg.phase2.postsPerBlog, tiersPerPost: cfg.phase2.tiersPerPost },
    searchVolumes,
    summaryByKeyword,        // v17 UI
    finalStats               // v16 UI
  };
}


응답 tier 객체(서버 계산 바인딩):
{ text, volume, rank, score, adScore, eligible, skipReason }

프론트는 tier.score(없으면 adScore)를 바인딩. ||0 같은 기본값으로 덮지 않음.

7) 2어 조합(빅그램) 생성기(간결 규칙)
function expandBigrams(base:string, tokens:string[]){
  const out: {surface:string; variants:string[]}[] = [];
  for (const t of tokens) if (t!==base) {
    const s = `${base} ${t}`;
    const v = [s, s.replace(/\s+/g,''), s.length>10 ? s.replace(/\s+/g,'-') : null].filter(Boolean) as string[];
    out.push({ surface:s, variants:v });
  }
  return dedupeBy(out,'surface');
}


숫자 단독(‘2025’)·단일 불용어(‘정리/방법/추천/후기…’)는 단독 금지, 조합에서만 허용.

8) 관리자 설정(값만 있으면 사용)
{
  "phase2": { "tiersPerPost": 4 },                   // K (원하면 변경)
  "weights": { "volume": 0.70, "ads": 0.30 },
  "ads": { "wCtr": 0.4, "wComp": 0.4, "wCpc": 0.2 },
  "banSingles": ["정리","방법","추천","후기","테스트","여자","바르"],
  "features": { "preEnrich": true, "tierAutoFill": true },
  "adscore": { "mode": "soft", "SCORE_MIN": 0.35 }   // 제목 단계 완화
}

9) 빠른 스모크(2분)
# 새 분석
curl -s -X POST http://localhost:5000/api/serp/analyze \
 -H "Content-Type: application/json" \
 -d '{"keywords":["코엔자임Q10 먹는시간"],"mode":"phase2","postsPerBlog":10,"tiersPerPost":4}' | jq -r '.jobId'

# 결과 필드 확인(값이 채워졌는지)
curl -s http://localhost:5000/api/serp/jobs/<JOB_ID>/results \
 | jq '.. | objects | select(has("text") and has("score") and has("volume")) | {text,volume,score,eligible,skipReason} | .'


기대: text/volume/score(>0)/eligible가 채워지고, 빈 티어 없음. 레거시 화면도 finalStats.tiers로 표시.

10) 수용 기준(DoD)

제목 키워드가 DB에 없으면 전부 SearchAds로 채워지고(413/400 방어), 같은 요청 메모리에 merge 되어 volume이 숫자로 보임.

조합(빅그램) 이 생성되어 조회량·광고지표 반영 Top K가 선정(기본 4).

광고 불가/지표 0 키워드는 조합·선정·랭크에서 제외.

응답 tiers에 {text, volume, rank, score, adScore, eligible, skipReason}가 있고, finalStats.tiers에도 동일 데이터가 들어감.

정규화 일치로 코엔자임Q10/코엔자임q10 혼선 없음.

11) 문제시 즉시 롤백 스위치(설정만)
{
  "phase2": { "engine": "ngrams" },
  "features": { "preEnrich": false, "tierAutoFill": false },
  "adscore": { "mode": "hard", "SCORE_MIN": 0.0 }
}