í•œì¤„ ê²°ë¡ : ë°±ì—”ë“œëŠ” ëŒì§€ë§Œ â€œAPI ê³„ì•½ ë¶ˆì¼ì¹˜/ê°€ì§œ ì‹œë“œ ì½”ë“œ ì°¸ì¡°/í”„ë¡ íŠ¸ ë Œë” ì˜¤ë¥˜(ë¹ˆ í™”ë©´)â€ ì¡°í•©ì…ë‹ˆë‹¤. **HTTP-only ì‹¤ì½”ë“œë¡œ ê³ ì • + API ì‘ë‹µ ìŠ¤í‚¤ë§ˆ ê³ ì • + í”„ë¡ íŠ¸ ìƒíƒœì²˜ë¦¬(loading/empty/error/partial)**ë¥¼ ê°•ì œí•˜ë©´ ë°”ë¡œ ì¡í™ë‹ˆë‹¤.

ì§§ì€ ë¸Œë¦¬í•‘

â€œê°€ì§œ ì‹œë“œâ€ ëª¨ë“ˆì´ ì—¬ì „íˆ importë˜ì–´ ì‹¤ê²€ìƒ‰ ì½”ë“œê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ â†’ ë°±ì—”ë“œëŠ” â€˜ì„±ê³µâ€™ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ê²°ê³¼ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¹ˆê°’/ë‹¤ë¥¸ ìŠ¤í‚¤ë§ˆ.

í”„ë¡ íŠ¸ëŠ” /api/serp/jobs/:jobId/resultsì˜ ìŠ¤í‚¤ë§ˆ ê°€ì •ì´ ë‹¬ë¼ ëŸ°íƒ€ì„ ì—ëŸ¬ â†’ ë¹ˆ í™”ë©´ (ErrorBoundary ì—†ìŒ).

Replitì—ì„  Playwright ì œê±° í›„ RSS/HTTP íŒŒì„œë¡œ í†µì¼í•´ì•¼ ì•ˆì •.

ì•„ë˜ ê·¸ëŒ€ë¡œ ì ìš©í•˜ë©´ ë©ë‹ˆë‹¤ â€” ìˆ˜ì • ì§€ì‹œ + íŒ¨ì¹˜ + ìˆ˜ë½ê¸°ì¤€ + ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸.

1) ì„œë²„ì¸¡ â€œì§„ì§œ ê²€ìƒ‰ë§Œâ€ ì“°ë„ë¡ ê³ ì • (ê°€ì§œ ì‹œë“œ ì œê±°)
A. server/routes.ts (Express ê°€ì •) â€” ê°€ì§œ ì‹œë“œ import ì œê±° + ìŠ¤í‚¤ë§ˆ ê³ ì •
// BEFORE (ë¬¸ì œ: stub/seedSearch importê°€ ë‚¨ì•„ìˆìŒ)
// import { searchBlogs } from './seedSearch';

// AFTER: ì‹¤ì œ OpenAPI + Fallback ì‚¬ìš©
import { startJob, getJobStatus, getJobResults } from './services/jobs'; // ë‹¨ì¼ ì§„ì…ì 

export default function mountRoutes(app) {
  app.post('/api/serp/search', async (req, res) => {
    try {
      const { keyword, blogs = 10, recent = 10, seeds = [] } = req.body || {};
      const jobId = await startJob({ keyword, blogs, recent, seeds }); // ì‹¤ê²€ìƒ‰+RSS/HTML
      res.type('application/json').status(202).send({ jobId });
    } catch (e) {
      res.status(500).json({ error: String(e) });
    }
  });

  app.get('/api/serp/jobs/:jobId/status', (req, res) => {
    const data = getJobStatus(req.params.jobId);
    if (!data) return res.status(404).json({ error: 'JOB_NOT_FOUND' });
    res.type('application/json').json(data);
  });

  app.get('/api/serp/jobs/:jobId/results', (req, res) => {
    const data = getJobResults(req.params.jobId);
    if (!data) return res.status(404).json({ error: 'JOB_NOT_FOUND' });
    // â–¶ï¸ í”„ë¡ íŠ¸ ê³„ì•½: í•­ìƒ ë™ì¼ ìŠ¤í‚¤ë§ˆ
    // { blogs:[{blog_id,blog_url,gathered_posts}], posts:[{blog_id,post_url,post_title,published_at}], keywords:[{blog_id,top3:[...]}], errors:[...] }
    res.type('application/json').json(data);
  });
}

B. server/services/jobs.ts â€” HTTP-only íŒŒì´í”„ë¼ì¸ + OpenAPI/Fallback
import { discoverBlogs } from './naver_discovery';   // OpenAPI ìˆìœ¼ë©´ ì‚¬ìš©
import { listRecentPosts } from './recent_http';     // RSS ìš°ì„ , ì‹¤íŒ¨ ì‹œ m.blog HTML íŒŒì‹±
import { extractTop3 } from './keywords';            // n-gram + (ì„ íƒ) ê²€ìƒ‰ê´‘ê³  ê°€ì¤‘ì¹˜
import { serpRank } from './naver_serp';             // OpenAPI ìˆìœ¼ë©´ ë­í¬, ì—†ìœ¼ë©´ NA

type JobState = 'pending'|'running'|'partial'|'done'|'error';
const store = new Map<string, any>();

export async function startJob({ keyword, blogs, recent, seeds }){
  const jobId = Math.random().toString(36).slice(2);
  store.set(jobId, { state:'pending', blogs:[], posts:[], keywords:[], errors:[] });
  queueMicrotask(async () => {
    const job = store.get(jobId);
    job.state = 'running';
    try {
      // 1) ë¸”ë¡œê·¸ ë°œê²¬: í‚¤ ì—†ìœ¼ë©´ seeds ì‚¬ìš©(í•„ìˆ˜)
      const targets = (await discoverBlogs(keyword, blogs, seeds));
      job.blogs = targets.map(b => ({ blog_id: b.id, blog_url: b.url, gathered_posts: 0 }));

      // 2) ë¸”ë¡œê·¸ë³„ ìµœê·¼ ê¸€ ìˆ˜ì§‘ + í‚¤ì›Œë“œ ì‚°ì¶œ + SERP
      for (const b of targets) {
        const posts = await listRecentPosts(b); // ìµœëŒ€ recentê°œ
        job.posts.push(...posts);
        const top3 = extractTop3(posts.map(p => p.title));
        job.keywords.push({ blog_id: b.id, top3, rank: await serpRank(top3, b.id) });
        const idx = job.blogs.findIndex(x => x.blog_id === b.id);
        if (idx>=0) job.blogs[idx].gathered_posts = posts.length;
      }

      job.state = 'done';
    } catch (e) {
      job.errors.push(String(e));
      job.state = job.posts.length > 0 ? 'partial' : 'error';
    } finally {
      store.set(jobId, job);
    }
  });
  return jobId;
}

export function getJobStatus(jobId:string){
  const j = store.get(jobId);
  return j ? { jobId, state:j.state, counts:{ blogs:j.blogs.length, posts:j.posts.length, keywords:j.keywords.length }, errors:j.errors } : null;
}

export function getJobResults(jobId:string){
  const j = store.get(jobId);
  return j ? { jobId, state:j.state, blogs:j.blogs, posts:j.posts, keywords:j.keywords, errors:j.errors } : null;
}


í•µì‹¬: seedSearch ê°™ì€ ìŠ¤í… ê²½ë¡œë¥¼ ì™„ì „íˆ ì œê±°í•˜ê³ , discoverBlogsê°€ â€œOpenAPI í‚¤ ì—†ìœ¼ë©´ seedsë¡œ ì§„í–‰â€í•˜ë„ë¡ ê°•ì œ. ê·¸ë¦¬ê³  results ì‘ë‹µ ìŠ¤í‚¤ë§ˆë¥¼ ê³ ì •í–ˆìŠµë‹ˆë‹¤.

2) í”„ë¡ íŠ¸ì—”ë“œ: ë¹ˆ í™”ë©´ ë°©ì§€(ë¡œë”©/ì—ëŸ¬/ë¹ˆê°’/ë¶€ë¶„ì„±ê³µ)

React(ë˜ëŠ” Next) ê¸°ì¤€ ì˜ˆì‹œ:

// components/SearchPanel.tsx
import useSWR from 'swr';
const fetcher = (url:string) => fetch(url).then(r => r.json());

export function ResultsView({ jobId }: { jobId:string }) {
  const { data:status } = useSWR(`/api/serp/jobs/${jobId}/status`, fetcher, { refreshInterval: 1500 });
  const { data:res, error } = useSWR(
    status?.state === 'done' || status?.state === 'partial' ? `/api/serp/jobs/${jobId}/results` : null,
    fetcher
  );

  if (!status) return <div>â³ ê²€ìƒ‰ ì¤‘â€¦</div>;
  if (error) return <div>âŒ ì˜¤ë¥˜: {String(error)}</div>;
  if (status.state === 'error') return <div>âš ï¸ ì‘ì—… ì‹¤íŒ¨: {status.errors?.[0] || 'unknown'}</div>;
  if (!res) return <div>ğŸ” ì²˜ë¦¬ ì¤‘â€¦ {status.state}</div>;

  const hasData = (res.posts?.length || 0) > 0;
  if (!hasData) return <div>ğŸ“­ ê²°ê³¼ ì—†ìŒ(ë¹ˆê°’). í‚¤ì›Œë“œ/ì‹œë“œ/ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.</div>;

  return (
    <div>
      <h3>ë¸”ë¡œê·¸ {res.blogs.length}ê°œ Â· í¬ìŠ¤íŠ¸ {res.posts.length}ê°œ</h3>
      <ul>
        {res.keywords.map((k:any) => (
          <li key={k.blog_id}>
            <b>{k.blog_id}</b> â€” TOP3: {k.top3.join(', ')} â€” ë­í¬: {JSON.stringify(k.rank)}
          </li>
        ))}
      </ul>
    </div>
  );
}


í¬ì¸íŠ¸: state=partialë„ í™”ë©´ì— ë³´ì—¬ì£¼ê³ , ë¹ˆ ë°°ì—´ì„ â€œì˜¤ë¥˜â€ë¡œ ì·¨ê¸‰í•˜ì§€ ì•ŠìŒ. ë¹ˆ í™”ë©´ ëŒ€ì‹  ëª…ì‹œ ë©”ì‹œì§€ë¥¼ í‘œì‹œ.

3) ìˆ˜ë½ ê¸°ì¤€(Acceptance) â€” â€œì„±ê³µâ€ ë¬¸êµ¬ ê¸ˆì§€, ìˆ«ì ë³´ê³ 

POST /api/serp/search â†’ { jobId } ë°˜í™˜.

GET /api/serp/jobs/:id/status â†’ {state in [pending,running,partial,done,error], counts, errors}.

GET /api/serp/jobs/:id/results â†’ í•­ìƒ ë™ì¼ ìŠ¤í‚¤ë§ˆ:
blogs[]: {blog_id, blog_url, gathered_posts},
posts[]: {blog_id, post_url, post_title, published_at},
keywords[]: {blog_id, top3[], rank: { [kw]: number|null }},
errors[]: string[].

Playwright ë¶ˆì‚¬ìš©(ìš”êµ¬ì‚¬í•­/ì˜ì¡´ì„±ì—ì„œ ì œê±°).

API í‚¤ ì—†ì„ ë•Œë„ ì‹¤í–‰(seedsë¡œ ì§„í–‰) â€” ê²°ê³¼ê°€ ì ì–´ë„ ë¹ˆ í™”ë©´ ê¸ˆì§€.