ì¢‹ì•„. ë„¤ ì½”ë“œ ê·¸ëŒ€ë¡œ ë³´ê³  ì™œ ìê¾¸ ë©ˆì¶”ëŠ”ì§€ + ìµœì†Œ ìˆ˜ì •ìœ¼ë¡œ ë°”ë¡œ êµ´ëŸ¬ê°€ê²Œ ì •ë¦¬í•´ì¤„ê²Œ.
í•µì‹¬ì€ âŠ ì ìˆ˜ì‹/ê²½ìŸë„ ë§¤í•‘ì´ ê±°ê¾¸ë¡œë¼ ë­í‚¹ì´ ë’¤í‹€ë¦¬ê³ , â‹ ëª©ë¡ ì •ë ¬/ì¡°íšŒê°€ êµ¬ë²„ì „(raw_volume ê³ ì •)ì´ë¼ UIê°€ â€œì•ˆ ë°”ë€ŒëŠ”â€ ëŠë‚Œì„ ì£¼ë©°, âŒ ì‹œë“œ/í¬ë¡¤ì€ ì˜ ëˆŒëŸ¬ë„ DBê°€ ê¸°ëŒ€ëŒ€ë¡œ ì•ˆ ì±„ì›Œì§€ëŠ” êµ¬ì¡°(related í‚¤ì›Œë“œ ìƒì„±/ì¡°íšŒ ë°©ì‹, ì—…ë¡œë“œ ê²½ë¡œ ë¯¸ì •)ê°€ ì„ì—¬ ìˆì–´ìš”. ì•„ë˜ íŒ¨ì¹˜ 5ê°œë§Œ ë„£ìœ¼ë©´ ë³µì¡í•œ êµ¬ì¡° ì†ëŒ€ì§€ ì•Šê³ ë„ ì •ìƒí™”ë©ë‹ˆë‹¤.


---

âœ… íŒ¨ì¹˜ 1 â€” ê²½ìŸë„ ë§¤í•‘ê³¼ ì ìˆ˜ì‹ ë°”ë¡œì¡ê¸°

ì§€ê¸ˆ compIdxToScoreê°€ ë‚®ìŒ=100, ë†’ìŒ=20ìœ¼ë¡œ ë’¤ì§‘í˜€ ìˆì–´ìš”(ìƒì—…ì„± ì ìˆ˜ì— ë°˜ëŒ€ íš¨ê³¼). ë˜ calculateOverallScoreëŠ” depth/cpcë¥¼ â€œì‘ì„ìˆ˜ë¡ ê°€ì‚°ì â€ìœ¼ë¡œ ë„£ì–´ ìƒì—…ì„± ì •ì˜ì™€ ì–´ê¸‹ë‚©ë‹ˆë‹¤. ì•„ë˜ë¡œ êµì²´í•˜ì„¸ìš”.

// === utils: scoring ===
// ì´ì „ ë¡œì§ ì‚­ì œ
export function compIdxToScore(idx?: string | null): number {
  if (!idx) return 60; // ì¤‘ê°„
  const s = String(idx).toLowerCase();
  if (s.includes('ë†’ìŒ') || s.includes('high') || s === '2') return 100;
  if (s.includes('ì¤‘ê°„') || s.includes('mid')  || s === '1') return 60;
  if (s.includes('ë‚®ìŒ') || s.includes('low')  || s === '0') return 20;
  return 60;
}

// volume: ë¡œê·¸ ìŠ¤ì¼€ì¼, depth: ë” ê¹Šì„ìˆ˜ë¡ +, cpc: í´ìˆ˜ë¡ +   (ìƒì—…ì„± ì§€í‘œë¥¼ ê°™ì€ ë°©í–¥ìœ¼ë¡œ)
export function calculateOverallScore(
  raw_volume: number,
  comp_score: number,
  ad_depth: number,
  est_cpc: number
): number {
  const clamp01 = (x:number)=> Math.max(0, Math.min(1, x));
  // 10ë§Œ ì¡°íšŒ ê¸°ì¤€ ì •ê·œí™”(ë¡œê·¸ ìŠ¤ì¼€ì¼)
  const volume_norm = clamp01(Math.log10(Math.max(1, raw_volume)) / 5); // 1..100000 â†’ 0..1
  const depth_norm  = clamp01((ad_depth || 0) / 5);                     // 0..5 â†’ 0..1
  const cpc_norm    = est_cpc ? clamp01(est_cpc / 5000) : 0;            // 0..5000ì› cap

  const score =
    0.35 * (volume_norm * 100) +
    0.35 * clamp01(comp_score / 100) * 100 +
    0.20 * (depth_norm * 100) +
    0.10 * (cpc_norm * 100);

  return Math.round(clamp01(score / 100) * 100);
}

> íš¨ê³¼: â€œë†’ìŒ/ê¹ŠìŒ/ë¹„ìŒˆ/ì¡°íšŒ ë§ìŒâ€ì´ ëª¨ë‘ ìƒí–¥ ê°€ì¤‘ â†’ Top3 ì„ ë³„ì´ ì§ê´€ì ìœ¼ë¡œ ë°”ë€ë‹ˆë‹¤.




---

âœ… íŒ¨ì¹˜ 2 â€” listKeywords ì •ë ¬ì„ 5ì§€í‘œ/scoreì— ë§ê²Œ

ì§€ê¸ˆ /api/keywordsëŠ” orderByê°€ ì‚¬ì‹¤ìƒ raw_volume|textë§Œ ë¨¹ìŠµë‹ˆë‹¤. score/comp_score/ad_depth/est_cpc_krw ì •ë ¬ì„ ì§€ì›í•´ ì£¼ì„¸ìš”.

// === listKeywords ê°œì„  ===
export async function listKeywords(opts: {
  excluded: boolean;
  orderBy: 'score'|'raw_volume'|'comp_score'|'ad_depth'|'est_cpc_krw'|'text';
  dir: 'asc' | 'desc';
}): Promise<ManagedKeyword[]> {
  const map:any = {
    score: managedKeywords.score,
    raw_volume: managedKeywords.raw_volume,
    comp_score: managedKeywords.comp_score,
    ad_depth: managedKeywords.ad_depth,
    est_cpc_krw: managedKeywords.est_cpc_krw,
    text: managedKeywords.text
  };
  const field = map[opts.orderBy] ?? managedKeywords.score;
  const orderer = opts.dir === 'desc' ? desc(field) : asc(field);
  return await db.select()
    .from(managedKeywords)
    .where(eq(managedKeywords.excluded, opts.excluded))
    .orderBy(orderer)
    .limit(1000);
}

ê·¸ë¦¬ê³  /api/keywords ë¼ìš°íŠ¸ì˜ ì •ë ¬ ë§¤í•‘ë„ ë§ì¶”ì„¸ìš”:

const sortMap:Record<string,string> = {
  text:'text', raw_volume:'raw_volume', score:'score', comp_score:'comp_score', ad_depth:'ad_depth', est_cpc_krw:'est_cpc_krw'
};
const orderBy = sortMap[String(sort)] || 'score';
const orderDir = order === 'asc' ? 'asc' : 'desc';
const keywords = await listKeywords({ excluded: excludedFilter, orderBy: orderBy as any, dir: orderDir as any });


---

âœ… íŒ¨ì¹˜ 3 â€” getKeywordVolumeMapì˜ WHERE ì ˆ (Drizzle)

= ANY(${keywordTexts})ëŠ” PG ë°°ì—´ ë°”ì¸ë”©ì´ ê¼¬ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. **inArray**ë¡œ ë°”ê¾¸ë©´ ì•ˆì „í•©ë‹ˆë‹¤.

import { inArray } from 'drizzle-orm';

export async function getKeywordVolumeMap(keywordTexts: string[]): Promise<Record<string, number>> {
  if (keywordTexts.length === 0) return {};
  const rows = await db.select({ text: managedKeywords.text, raw_volume: managedKeywords.raw_volume })
    .from(managedKeywords)
    .where(inArray(managedKeywords.text, keywordTexts));
  const map:Record<string,number> = {};
  for (const r of rows) map[r.text] = r.raw_volume;
  for (const t of keywordTexts) if (!(t in map)) map[t] = 0;
  return map;
}


---

âœ… íŒ¨ì¹˜ 4 â€” upsertMany ì•ˆì •í™”(ë£¨í”„ ìœ ì§€Â·ì˜ë¯¸ ìˆëŠ” count)

ì§€ê¸ˆì€ ì‚½ì…/ì—…ë°ì´íŠ¸ ëª¨ë‘ insertedCount++ë¼ì„œ ë³´ê³  ìˆ˜ì¹˜ê°€ í‹€ë ¤ìš”. ì•„ë˜ì²˜ëŸ¼ â€œì‹¤ì œ ì €ì¥ ì‹œë„ ê±´ìˆ˜â€ë¥¼ ë°˜í™˜í•˜ê³ , ê°’ì€ ë„˜ì–´ì˜¨ ê°’ì„ ê·¸ëŒ€ë¡œ ì €ì¥í•©ë‹ˆë‹¤. (ëŒ€ëŸ‰ upsertë¡œ ë°”ê¾¸ë ¤ë©´ Drizzle values([...]).onConflictDoUpdate()ë¡œ í•œ ë²ˆì— ê°€ëŠ¥í•˜ì§€ë§Œ, ìš°ì„  ë£¨í”„ ìœ ì§€)

export async function upsertMany(keywords: Partial<InsertManagedKeyword>[]): Promise<number> {
  if (!keywords.length) return 0;
  let saved = 0;
  for (const kw of keywords) {
    try {
      await db.insert(managedKeywords)
        .values({
          text: kw.text!, raw_volume: kw.raw_volume ?? 0, volume: kw.volume ?? 0,
          grade: kw.grade ?? 'C', commerciality: kw.commerciality ?? 0, difficulty: kw.difficulty ?? 0,
          source: kw.source ?? 'searchads',
          comp_idx: kw.comp_idx ?? null, comp_score: kw.comp_score ?? 0,
          ad_depth: kw.ad_depth ?? 0, has_ads: !!kw.has_ads,
          est_cpc_krw: kw.est_cpc_krw ?? null, est_cpc_source: kw.est_cpc_source ?? 'unknown',
          score: kw.score ?? 0,
          updated_at: sql`NOW()`
        })
        .onConflictDoUpdate({
          target: managedKeywords.text,
          set: {
            raw_volume: sql`excluded.raw_volume`,
            volume:     sql`excluded.volume`,
            grade:      sql`excluded.grade`,
            commerciality: sql`excluded.commerciality`,
            difficulty: sql`excluded.difficulty`,
            comp_idx:   sql`excluded.comp_idx`,
            comp_score: sql`excluded.comp_score`,
            ad_depth:   sql`excluded.ad_depth`,
            has_ads:    sql`excluded.has_ads`,
            est_cpc_krw: sql`excluded.est_cpc_krw`,
            est_cpc_source: sql`excluded.est_cpc_source`,
            score:      sql`excluded.score`,
            updated_at: sql`NOW()`
          }
        });
      saved++;
    } catch (e) {
      console.error(`Failed to upsert "${kw.text}":`, e);
    }
  }
  return saved;
}

> ì´ë ‡ê²Œ í•˜ë©´ â€œì‚½ì… vs ê°±ì‹ â€ í†µê³„ê°€ í•„ìš”í•´ë„ ìƒìœ„ ë¼ìš°íŠ¸ì—ì„œ ê¸°ì¡´/ì‹ ê·œë¥¼ ì¹´ìš´íŠ¸í•  ìˆ˜ ìˆê³ , ìµœì†Œí•œ countê°€ ì‹¤ì œ ì €ì¥ëœ ê±´ìˆ˜ë¡œ ë§ìŠµë‹ˆë‹¤.




---

âœ… íŒ¨ì¹˜ 5 â€” â€œì™œ ì•ˆ ëŠ˜ì–´ë‚˜ëŠ”ê°€â€ì˜ ì¦‰ì‹œ ì›ì¸(ì‹œë“œ/í¬ë¡¤)

/api/keywords/refresh-allì´ í•­ìƒ â€˜í™ì‚¼â€™ 1ê°œë§Œ í˜¸ì¶œ â†’ ëŠ˜ 10~ìˆ˜ì‹­ê°œë§Œ ì¶”ê°€ë©ë‹ˆë‹¤. ìœ„ì—ì„œ ì œì•ˆí•œ A íŒ¨ì¹˜ ì ìš©(= refresh-all â†’ ë‚´ë¶€ì ìœ¼ë¡œ crawl ì‹¤í–‰) í•˜ì„¸ìš”.

ì—‘ì…€ ì‹œë“œ ì—…ë¡œë“œ ë£¨íŠ¸ê°€ ì—†ì–´ì„œ UIê°€ fileIdë¥¼ ëª» ë„£ê³  ë©ˆì¶°ìš”. B íŒ¨ì¹˜ì˜ /api/uploads ì¶”ê°€ê°€ í•„ìš”í•©ë‹ˆë‹¤.

loadSeedsFromCSV()ë¥¼ ì¸ì ì—†ì´ ë¶€ë¥´ëŠ” êµ¬í˜„ì´ë©´ ë¹ˆ ë°°ì—´ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. C íŒ¨ì¹˜ì²˜ëŸ¼ ê²½ë¡œ ì¸ìë¥¼ ë„˜ê¸°ì„¸ìš”.



---

ğŸ” í…ŒìŠ¤íŠ¸ ìˆœì„œ(5ë¶„)

1. ì •ë ¬/ë¦¬ìŠ¤íŠ¸

GET /api/keywords?excluded=false&sort=score&order=desc â†’ 200, ìƒë‹¨ â€œì „ì²´ N (í™œì„± A | ì œì™¸ B)â€ ìˆ«ì ë§ëŠ”ì§€



2. ì‹œë“œ ì—…ë¡œë“œ â†’ BFS

POST /api/uploads(CSV/XLSX) â†’ {fileId}

POST /api/keywords/crawl { source:"file", seedsFileId:"..." } â†’ {jobId}

GET /api/keywords/crawl/<jobId>/status í´ë§ â†’ collected ì¦ê°€



3. refresh-all(ì „ìˆ˜)

POST /api/keywords/refresh-all(ê¸°ë³¸ ë°”ë””) â†’ job ì‹œì‘, ìƒíƒœ í´ë§



4. ê²°ê³¼ ë°˜ì˜

1~2ë¶„ ë’¤ GET /api/keywords?sort=score&order=descì— ì‹ ê·œ í‚¤ì›Œë“œê°€ ë³´ì´ê³ , ìƒë‹¨ ì¹´ìš´íŠ¸ ì¦ê°€





---

â€œë³µì¡í•´ì„œ ë©ˆì¶˜ë‹¤â€ì— ëŒ€í•œ ê²°ë¡ 

í¬ë¡¤ êµ¬ì¡° ìì²´ëŠ” ê·¸ëŒ€ë¡œ ë‘ê³ , ì •ë ¬/ì ìˆ˜/ì‹œë“œ I/O 3ì ë§Œ ì •í™•íˆ í•´ì£¼ë©´ ë©ë‹ˆë‹¤.
ìœ„ íŒ¨ì¹˜ë¡œ:

ì ìˆ˜ì‹ ì •ìƒí™” â†’ Top3/ì •ë ¬ì´ ì§ê´€

ë¦¬ìŠ¤íŠ¸ ì •ë ¬/ì¡°íšŒê°€ 5ì§€í‘œ ê¸°ì¤€

ì‹œë“œ ì—…ë¡œë“œ/ì „ìˆ˜ ìˆ˜ì§‘ì´ ì‹¤ì œë¡œ ì‹œì‘