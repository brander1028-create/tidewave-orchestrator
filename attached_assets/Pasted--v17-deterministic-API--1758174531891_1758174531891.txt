최종 정의서(“이제 이대로만”): v17-deterministic + 하이브리드 최소 API

아래는 우리가 여기까지 합의했던 모든 규칙을 한 문서에 “꽂을 수 있게” 정리한 최종 사양이에요.
핵심 목표는 ① 폭주/루프/크래시 금지 ② 2~4티어 빅그램 고정 ③ 제목 토큰만 사용 ④ 실제 조회량과 최대한 일치 ⑤ 결과가 항상 저장·표시되는 것.

0) 용어/모드

v17-deterministic: 최종/단일 파이프라인. 제목 토큰만, 결정론적 티어 규칙, DB 우선, 필요 시 최소 API(옵션2)만 호출.

vFinal/v10/legacy: 모두 금지(코드 레벨 가드 포함).

DET 플래그: DETERMINISTIC_ONLY=true면 외부 API 전면 차단(DB-only); false면 옵션2(최소 API) 허용.

1) 라우팅을 “하나”로 고정
/api/serp/search (server/routes.ts)

기본 모드는 v17-deterministic로 강제 고정.

요청 Body/Query에 다른 파이프라인/모드가 와도 무시.

실행 전 헬스 프리체크:

DET=true → OpenAPI+DB OK면 진행(외부 SearchAds는 어차피 차단).

DET=false(하이브리드) → OpenAPI+DB OK이면 진행. SearchAds 상태는 무시(옵션2의 “최소 호출”이기 때문).

금지: vFinal/v10/legacy 분기 삭제 또는 return 전 주석 처리.

2) 전역 가드(Defense-in-Depth)
(A) SearchAds 호출부 차단

server/services/searchad.ts

const DET = process.env.DETERMINISTIC_ONLY === 'true';
if (DET) return { rows: [], source: 'blocked_in_deterministic' };


server/services/externals-health.ts (getVolumesWithHealth 진입부)

const DET = process.env.DETERMINISTIC_ONLY === 'true';
if (DET) return { volumes:{}, hits:0, refreshed:0, mode:'db-only' };

(B) vFinal/legacy 진입 차단

vFinal(파일 단위) export 하는 퍼블릭 진입 함수 최상단:

if (process.env.DETERMINISTIC_ONLY === 'true') 
  throw new Error('vFinal is disabled in deterministic mode');


어떤 로그에서도 vFinal/Batch: ... 413 error/Trying minimal variants가 보이면 중단(回帰 테스트 항목 참조).

3) 제목→토큰 추출(Title tokens only)
(A) 공통 상수

MAX_TITLE_TOKENS = 6

불용어/조사/접속사 BAN: 정리, 방법, 추천, 후기, 및, 과, 와, 의, 이, 오늘의, 테스트...

로컬/지명 사전: 국내 시/군/구/동 풀셋 + 해외 대도시(상하이, 도쿄 등).
→ 단일 금지, 빅그램 허용.

특수 규칙: ‘맛집’

단일 금지

빅그램 허용(예: 평택 맛집, 잠실 맛집)

(B) 추출 함수 (server/services/title-keyword-extractor.ts)
export function extractTitleTokens(title:string): string[] {
  return tokenize(title)
    .map(nrm)                         // 정규화
    .filter(t => t.length >= 2)
    .filter(t => !BAN.has(t))
    .slice(0, MAX_TITLE_TOKENS);
}

4) 결정론적 티어 규칙 (v17-deterministic)

항상 1~4티어을 이 규칙으로 만든다. (Phase2 엔진/랭킹 기반 후보 생성 없음)

Step 1) 기본 후보

tokens = extractTitleTokens(title)

vol(token) = DB.volume(token) (DET=false에서 DB miss이고 선정된 키워드일 때만 최소 API 호출 허용. 상세는 §5)

Step 2) T1(단일) 선정

후보 = tokens 중 로컬/맛집 제외 + BAN 제외.

스코어 = volume 70% + (adScore) 30%
단, DET=true 또는 DB-only일 땐 adScore=0 취급(가짜/폴백값 금지).

T1 = 스코어 최대의 단일.

만약 단일이 1개도 없다면:

빅그램 후보 = makeBigrams(tokens)

T1을 “빅그램” 중 스코어 최대로 승격(대체 베이스).
→ 이때도 스코어는 동일 공식(DET이면 adScore=0).

단, 여기서 ‘맛집’/‘로컬’ 포함 빅그램 허용.

Step 3) T2~T4 = “항상 빅그램”

**T2~T4는 모두 “T1을 포함하는 빅그램”**만 허용.

우선순위(두 번째 토큰 선택):

맛집 (가능하면 최우선)

로컬명(시/구/동/해외도시)

그 외 토큰 중 조회량 상위

중복 금지(이미 선택한 조합 제외), 총 3개가 채워질 때까지.

후보 부족 시: T1 + 상위 N 토큰 형태로 채움(최대 3개). 그래도 부족하면 남는 티어는 빈 티어로 두지 않는다 → 필수 4티어.

예시(사용자 기대대로)
제목: “평택 맛집 추천 기린아 미군부대 돈카츠”

T1: 돈카츠

T2: 평택 맛집

T3: 평택 맛집 추천

T4: 평택 돈카츠 (또는) 평택 돈카츠 맛집

5) 하이브리드 최소 API(옵션2)

원칙: 오직 “선정된 조합”만 API로 보충.
절대 연관키워드/확장어/전수 갱신 금지.

DET=false일 때만 동작.

API 대상: T1, T1+X 3개 총 최대 4개.

DB miss에만 API 1회 시도(각 키워드 최대 1번). 실패(400/413 등) 시 그 키워드는 0/unknown으로 고정, 재시도 금지.

예산: API_BUDGET_PER_JOB = 4(고정). 초과 호출 절대 금지.

TTL: source='fallback'/0-vector는 Fresh 아님. 'api_ok'만 Fresh.

구현 위치:

server/services/v17-pipeline.ts 내부에서 T1, T2, T3, T4 확정 직후에만 getVolumesWithHealth(DB-first) 호출

externals-health.ts에서 옵션2 전용 분기: 대상 리스트 외 아무 것도 갱신하지 않음

6) 게이트 정책(Gate)

디터미니스틱/옵션2에서는 게이트 완화

T1: ad_eligible 하드컷 적용하지 않음(DB가 빈약할 때 0 연쇄를 막기 위함).

T2~T4: ad_eligible === true면 +3점, false면 0점*(하드컷 아님)*.

**폴백 값(ad=0, cpc=100, comp=60 같은 가짜 벡터)**는 절대 상업성 판단에 사용하지 말고, ad_eligible=false로 취급.

BAN(불용어/조사류), 단일 ‘맛집’, 단일 로컬명은 항상 제외(티어 후보에서 컷).

7) SERP 랭킹 체크(모바일) — 센티넬 중단

serpScraper(m.naver.com 기준):

“검색결과 더보기” / “서치피드 더 다양한 콘텐츠” 문구 발견 시 즉시 중단 (그 아래는 무의미)

blogId 추출 로그는 처음 10개 + 이후 20개마다 1회만 출력(레이트 리밋)

8) 저장 & 결과 API (필수)
저장

언제나 post_tier_checks에 저장.
isTestMode 예외 삭제(jobId가 test라도 저장).

저장 필드: jobId, blogId, postId, postTitle, tier(1~4), textSurface, textNrm, volume, rank, score, adscore, eligible, skipReason.

결과 API (GET /api/serp/jobs/:id/results)

readOnly 분기 삭제. DB에서 post_tier_checks로 조립하여 반드시 반환.

빈 결과면 빈 배열을 주되, 400/412는 금지(프론트가 멈추는 원인).

9) 로깅 체크리스트(안티-회귀)

필수로 나와야 하는 로그

🎯 [v17-DETERMINISTIC] Starting pipeline

📝 [v17] Extracted X tokens: ...

🎯 [T1 Final] ...

🎯 [T2 Final] ... ~ T4 Final

💾 [v17 Pipeline] Saving 4 tiers to database

GET /api/serp/jobs/:id/results 200

절대 나오면 안 되는 로그

vFinal / LK Engine / Phase2 engine

Batch: ... 413 error / Trying minimal variants / Minimal variants also failed

HYBRID MODE (디터모드에서)

No v17 data found ... readOnly mode

10) 환경 변수/상수
DETERMINISTIC_ONLY=true        # DB-only (실제 API 완전 차단). false면 옵션2 최소 API 허용
API_BUDGET_PER_JOB=4          # 옵션2에서 최대 4건
HEALTH_PROBE_SEARCHADS=false  # 헬스체크 중 SearchAds 금지
MAX_TITLE_TOKENS=6            # 제목 토큰 상한
MAX_BIGRAMS_FOR_TIERS=12      # (내부) 빅그램 만들 때 상한

11) 파일별 편집 포인트(요약)

server/routes.ts

/api/serp/search → v17-deterministic 고정, 헬스 프리체크, 412 완화(DET일 때)

/api/serp/jobs/:id/results → readOnly 삭제, DB 직조립

server/services/v17-pipeline.ts

Phase2/legacy 호출 제거

HYBRID 경로 비활성

T1/T2~T4 결정론 로직 구현(§4)

옵션2 최소 API: 티어 확정 후 DB miss 1회 보충(최대 4건)

server/services/title-keyword-extractor.ts

extractTitleTokens BAN/로컬/맛집 규칙 반영(§3)

server/services/searchad.ts, externals-health.ts

DET 가드/옵션2 최소 호출 로직(§2, §5)

server/services/serp-scraper.ts

모바일 문구 센티넬 중단(§7)

blogId 로그 rate-limit

12) 5분 스모크 테스트

DET=true(DB-only)

“잠실 맛집” 실행 → 로그에 vFinal/413/Hybrid 없어야 함

post_tier_checks에 4행 저장 확인

결과 페이지 200 & 티어 4개 표시

DET=false(옵션2 최소 API)

“평택 맛집 추천 기린아 미군부대 돈카츠” 실행

API 호출 최대 4건(T1/T2/T3/T4만)

평택 맛집, 평택 맛집 추천, 평택 돈카츠(맛집) 조합 포함 여부 확인

안티 회귀 로그 검사

금지 로그 한 줄이라도 나오면 FAIL로 처리.

13) 왜 이렇게 해야 정확도가 맞아지나?

제목 토큰만 쓰면 “연관어 폭증 → 413/400 → 크래시” 루프가 사라집니다.

2~4티어 빅그램 고정은 사용자 기대(노출 전략)와 일치하고, 로컬·맛집 정책을 자연스럽게 녹입니다.

옵션2 최소 API는 선정된 키워드들만 실제 조회량 갱신 → 비용과 실패율 최소화.

폴백/가짜 벡터를 상업성 판단에 쓰지 않기 때문에 “CPC=100, AD=0” 같은 틀린 점수가 결과를 망치지 않습니다.

readOnly 제거 + 항상 저장으로 결과 페이지가 항상 뜹니다.

14) 자주 틀렸던 포인트(금지 목록)

제목 밖 연관어 조회(❌)

HYBRID에서 v10/vFinal 호출(❌)

전체 후보/전수 API 갱신(❌)

단일 ‘맛집’/로컬을 T1로(❌)

ad_eligible을 DET에서도 하드컷(❌)

결과 API에서 빈 응답/412 반환(❌)

이 문서 그대로만 반영하면,

터지는 일이 멈추고,

2~4티어 빅그램이 항상 채워지고,

조회량/점수도 옵션2에서 실제값으로 보정됩니다.